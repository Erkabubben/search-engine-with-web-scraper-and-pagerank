time complexity from wikipedia the free encyclopedia redirected from computation time jump to navigation jump to search estimate of time taken for running an algorithm running time redirects here for the film see running time film graphs of functions commonly used in the analysis of algorithms showing the number of operations n as the result of input size n for each function in computer science the time complexity is the computational complexity that describes the amount of computer time it takes to run an algorithm time complexity is commonly estimated by counting the number of elementary operations performed by the algorithm supposing that each elementary operation takes a fixed amount of time to perform thus the amount of time taken and the number of elementary operations performed by the algorithm are taken to be related by a constant factor since an algorithm s running time may vary among different inputs of the same size one commonly considers the worst case time complexity which is the maximum amount of time required for inputs of a given size less common and usually specified explicitly is the average case complexity which is the average of the time taken on inputs of a given size this makes sense because there are only a finite number of possible inputs of a given size in both cases the time complexity is generally expressed as a function of the size of the input 91 1 93 58 8202 226 8202 since this function is generally difficult to compute exactly and the running time for small inputs is usually not consequential one commonly focuses on the behavior of the complexity when the input size increases that is the asymptotic behavior of the complexity therefore the time complexity is commonly expressed using big o notation typically o n displaystyle o n o n log x2061 n displaystyle o n log n o n x03b1 displaystyle o n alpha o 2 n displaystyle o 2 n etc where n is the size in units of bits needed to represent the input algorithmic complexities are classified according to the type of function appearing in the big o notation for example an algorithm with time complexity o n displaystyle o n is a linear time algorithm and an algorithm with time complexity o n x03b1 displaystyle o n alpha for some constant x03b1 gt 1 displaystyle alpha gt 1 is a polynomial time algorithm contents 1 table of common time complexities 2 constant time 3 logarithmic time 4 polylogarithmic time 5 sub linear time 6 linear time 7 quasilinear time 8 sub quadratic time 9 polynomial time 9 1 strongly and weakly polynomial time 9 2 complexity classes 10 superpolynomial time 11 quasi polynomial time 11 1 relation to np complete problems 12 sub exponential time 12 1 first definition 12 2 second definition 12 2 1 exponential time hypothesis 13 exponential time 14 factorial time 15 double exponential time 16 see also 17 references table of common time complexities edit further information computational complexity of mathematical operations the following table summarizes some classes of commonly encountered time complexities in the table poly x xo 1 i e polynomial in 160 x name complexity class running time t n examples of running times example algorithms constant time o 1 displaystyle o 1 10 finding the median value in a sorted array of numbers calculating 1 n inverse ackermann time o x03b1 n displaystyle o bigl alpha n bigr amortized time per operation using a disjoint set iterated logarithmic time o log x2217 x2061 n displaystyle o log n distributed coloring of cycles log logarithmic o log x2061 log x2061 n displaystyle o log log n amortized time per operation using a bounded priority queue 91 2 93 logarithmic time dlogtime o log x2061 n displaystyle o log n log x2061 n displaystyle log n log x2061 n 2 displaystyle log n 2 binary search polylogarithmic time poly log x2061 n displaystyle text poly log n log x2061 n 2 displaystyle log n 2 fractional power o n c displaystyle o n c where 0 lt c lt 1 displaystyle 0 lt c lt 1 n 1 2 displaystyle n frac 1 2 n 2 3 displaystyle n frac 2 3 searching in a kd tree linear time o n displaystyle o n n 2 n 5 displaystyle 2n 5 finding the smallest or largest item in an unsorted array kadane s algorithm linear search n log star n time o n log x2217 x2061 n displaystyle o n log n seidel s polygon triangulation algorithm linearithmic time o n log x2061 n displaystyle o n log n n log x2061 n displaystyle n log n log x2061 n displaystyle log n fastest possible comparison sort fast fourier transform quasilinear time n poly log x2061 n displaystyle n text poly log n n log 2 x2061 n displaystyle n log 2 n multipoint polynomial evaluation quadratic time o n 2 displaystyle o n 2 n 2 displaystyle n 2 bubble sort insertion sort direct convolution cubic time o n 3 displaystyle o n 3 n 3 displaystyle n 3 naive multiplication of two n x00d7 n displaystyle n times n matrices calculating partial correlation polynomial time p 2 o log x2061 n poly n displaystyle 2 o log n text poly n n 2 n displaystyle n 2 n n 10 displaystyle n 10 karmarkar s algorithm for linear programming aks primality test 91 3 93 91 4 93 quasi polynomial time qp 2 poly log x2061 n displaystyle 2 text poly log n n log x2061 log x2061 n displaystyle n log log n n log x2061 n displaystyle n log n best known o log2n approximation algorithm for the directed steiner tree problem sub exponential time first definition subexp o 2 n x03f5 displaystyle o 2 n epsilon for all x03f5 gt 0 displaystyle epsilon gt 0 contains bpp unless exptime see below equals ma 91 5 93 sub exponential time second definition 2 o n displaystyle 2 o n 2 n 3 displaystyle 2 sqrt 3 n best classical algorithm for integer factorization formerly best algorithm for graph isomorphism exponential time with linear exponent e 2 o n displaystyle 2 o n 1 1 n displaystyle 1 1 n 10 n displaystyle 10 n solving the traveling salesman problem using dynamic programming exponential time exptime 2 poly n displaystyle 2 text poly n 2 n displaystyle 2 n 2 n 2 displaystyle 2 n 2 solving matrix chain multiplication via brute force search factorial time o n displaystyle o n n displaystyle n solving the traveling salesman problem via brute force search double exponential time 2 exptime 2 2 poly n displaystyle 2 2 text poly n 2 2 n displaystyle 2 2 n deciding the truth of a given statement in presburger arithmetic constant time edit constant time redirects here for programming technique to avoid a timing attack see timing attack 160 avoidance an algorithm is said to be constant time also written as o 1 textstyle o 1 time if the value of t n textstyle t n the complexity of the algorithm is bounded by a value that does not depend on the size of the input for example accessing any single element in an array takes constant time as only one operation has to be performed to locate it in a similar manner finding the minimal value in an array sorted in ascending order it is the first element however finding the minimal value in an unordered array is not a constant time operation as scanning over each element in the array is needed in order to determine the minimal value hence it is a linear time operation taking o n textstyle o n time if the number of elements is known in advance and does not change however such an algorithm can still be said to run in constant time despite the name constant time the running time does not have to be independent of the problem size but an upper bound for the running time has to be independent of the problem size for example the task exchange the values of a and b if necessary so that a x2264 b textstyle a leq b is called constant time even though the time may depend on whether or not it is already true that a x2264 b textstyle a leq b however there is some constant t such that the time required is always at most t here are some examples of code fragments that run in constant time int index 5 int item list index if condition true then perform some operation that runs in constant time else perform some other operation that runs in constant time for i 1 to 100 for j 1 to 200 perform some operation that runs in constant time if t n displaystyle t n is o a displaystyle o a where a is any constant value this is equivalent to and stated in standard notation as t n displaystyle t n being o 1 displaystyle o 1 logarithmic time edit further information logarithmic growth an algorithm is said to take logarithmic time when t n o log x2061 n displaystyle t n o log n since log a x2061 n displaystyle log a n and log b x2061 n displaystyle log b n are related by a constant multiplier and such a multiplier is irrelevant to big o classification the standard usage for logarithmic time algorithms is o log x2061 n displaystyle o log n regardless of the base of the logarithm appearing in the expression of t algorithms taking logarithmic time are commonly found in operations on binary trees or when using binary search an o log x2061 n displaystyle o log n algorithm is considered highly efficient as the ratio of the number of operations to the size of the input decreases and tends to zero when n increases an algorithm that must access all elements of its input cannot take logarithmic time as the time taken for reading an input of size n is of the order of n an example of logarithmic time is given by dictionary search consider a dictionary d which contains n entries sorted by alphabetical order we suppose that for 1 x2264 k x2264 n displaystyle 1 leq k leq n one may access the kth entry of the dictionary in a constant time let d k displaystyle d k denote this kth entry under these hypotheses the test to see if a word w is in the dictionary may be done in logarithmic time consider d x230a n 2 x230b displaystyle d left left lfloor frac n 2 right rfloor right where x230a x230b displaystyle lfloor rfloor denotes the floor function if w d x230a n 2 x230b displaystyle w d left left lfloor frac n 2 right rfloor right then we are done else if w lt d x230a n 2 x230b displaystyle w lt d left left lfloor frac n 2 right rfloor right continue the search in the same way in the left half of the dictionary otherwise continue similarly with the right half of the dictionary this algorithm is similar to the method often used to find an entry in a paper dictionary polylogarithmic time edit an algorithm is said to run in polylogarithmic time if its time t n displaystyle t n is o log x2061 n k displaystyle o bigl log n k bigr for some constant k another way to write this is o log k x2061 n displaystyle o log k n for example matrix chain ordering can be solved in polylogarithmic time on a parallel random access machine 91 6 93 and a graph can be determined to be planar in a fully dynamic way in o log 3 x2061 n displaystyle o log 3 n time per insert delete operation 91 7 93 sub linear time edit an algorithm is said to run in sub linear time often spelled sublinear time if t n o n displaystyle t n o n in particular this includes algorithms with the time complexities defined above typical algorithms that are exact and yet run in sub linear time use parallel processing as the nc1 matrix determinant calculation does or alternatively have guaranteed assumptions on the input structure as the logarithmic time binary search and many tree maintenance algorithms do however formal languages such as the set of all strings that have a 1 bit in the position indicated by the first log x2061 n displaystyle log n bits of the string may depend on every bit of the input and yet be computable in sub linear time the specific term sublinear time algorithm is usually reserved to algorithms that are unlike the above in that they are run over classical serial machine models and are not allowed prior assumptions on the input 91 8 93 they are however allowed to be randomized and indeed must be randomized for all but the most trivial of tasks as such an algorithm must provide an answer without reading the entire input its particulars heavily depend on the access allowed to the input usually for an input that is represented as a binary string b 1 b k displaystyle b 1 b k it is assumed that the algorithm can in time o 1 displaystyle o 1 request and obtain the value of b i displaystyle b i for any i sub linear time algorithms are typically randomized and provide only approximate solutions in fact the property of a binary string having only zeros and no ones can be easily proved not to be decidable by a non approximate sub linear time algorithm sub linear time algorithms arise naturally in the investigation of property testing linear time edit an algorithm is said to take linear time or o n displaystyle o n time if its time complexity is o n displaystyle o n informally this means that the running time increases at most linearly with the size of the input more precisely this means that there is a constant c such that the running time is at most c n displaystyle cn for every input of size n for example a procedure that adds up all elements of a list requires time proportional to the length of the list if the adding time is constant or at least bounded by a constant linear time is the best possible time complexity in situations where the algorithm has to sequentially read its entire input therefore much research has been invested into discovering algorithms exhibiting linear time or at least nearly linear time this research includes both software and hardware methods there are several hardware technologies which exploit parallelism to provide this an example is content addressable memory this concept of linear time is used in string matching algorithms such as the boyer moore algorithm and ukkonen s algorithm quasilinear time edit an algorithm is said to run in quasilinear time also referred to as log linear time if t n o n log k x2061 n displaystyle t n o n log k n for some positive constant k 91 9 93 linearithmic time is the case k 1 displaystyle k 1 91 10 93 using soft o notation these algorithms are o x007e n displaystyle tilde o n quasilinear time algorithms are also o n 1 x03f5 displaystyle o n 1 epsilon for every constant x03f5 gt 0 displaystyle epsilon gt 0 and thus run faster than any polynomial time algorithm whose time bound includes a term n c displaystyle n c for any c gt 1 displaystyle c gt 1 algorithms which run in quasilinear time include in place merge sort o n log 2 x2061 n displaystyle o n log 2 n quicksort o n log x2061 n displaystyle o n log n in its randomized version has a running time that is o n log x2061 n displaystyle o n log n in expectation on the worst case input its non randomized version has an o n log x2061 n displaystyle o n log n running time only when considering average case complexity heapsort o n log x2061 n displaystyle o n log n merge sort introsort binary tree sort smoothsort patience sorting etc in the worst case fast fourier transforms o n log x2061 n displaystyle o n log n monge array calculation o n log x2061 n displaystyle o n log n in many cases the o n log x2061 n displaystyle o n log n running time is simply the result of performing a x0398 log x2061 n displaystyle theta log n operation n times for the notation see big o notation 160 family of bachmann landau notations for example binary tree sort creates a binary tree by inserting each element of the n sized array one by one since the insert operation on a self balancing binary search tree takes o log x2061 n displaystyle o log n time the entire algorithm takes o n log x2061 n displaystyle o n log n time comparison sorts require at least x03a9 n log x2061 n displaystyle omega n log n comparisons in the worst case because log x2061 n x0398 n log x2061 n displaystyle log n theta n log n by stirling s approximation they also frequently arise from the recurrence relation t n 2 t n 2 o n textstyle t n 2t left frac n 2 right o n sub quadratic time edit an algorithm is said to be subquadratic time if t n o n 2 displaystyle t n o n 2 for example simple comparison based sorting algorithms are quadratic e g insertion sort but more advanced algorithms can be found that are subquadratic e g shell sort no general purpose sorts run in linear time but the change from quadratic to sub quadratic is of great practical importance polynomial time edit an algorithm is said to be of polynomial time if its running time is upper bounded by a polynomial expression in the size of the input for the algorithm that is t n o nk for some positive constant k 91 1 93 91 11 93 problems for which a deterministic polynomial time algorithm exists belong to the complexity class p which is central in the field of computational complexity theory cobham s thesis states that polynomial time is a synonym for tractable feasible efficient or fast 91 12 93 some examples of polynomial time algorithms the selection sort sorting algorithm on n integers performs a n 2 displaystyle an 2 operations for some constant a thus it runs in time o n 2 displaystyle o n 2 and is a polynomial time algorithm all the basic arithmetic operations addition subtraction multiplication division and comparison can be done in polynomial time maximum matchings in graphs can be found in polynomial time strongly and weakly polynomial time edit in some contexts especially in optimization one differentiates between strongly polynomial time and weakly polynomial time algorithms these two concepts are only relevant if the inputs to the algorithms consist of integers strongly polynomial time is defined in the arithmetic model of computation in this model of computation the basic arithmetic operations addition subtraction multiplication division and comparison take a unit time step to perform regardless of the sizes of the operands the algorithm runs in strongly polynomial time if 91 13 93 the number of operations in the arithmetic model of computation is bounded by a polynomial in the number of integers in the input instance and the space used by the algorithm is bounded by a polynomial in the size of the input any algorithm with these two properties can be converted to a polynomial time algorithm by replacing the arithmetic operations by suitable algorithms for performing the arithmetic operations on a turing machine the second condition is strictly necessary given the integer 2 n displaystyle 2 n which takes up space proportional to n in the turing machine model it is possible to compute 2 2 n displaystyle 2 2 n with n multiplications using repeated squaring however the space used to represent 2 2 n displaystyle 2 2 n is proportional to 2 n displaystyle 2 n and thus exponential rather than polynomial in the space used to represent the input hence it is not possible to carry out this computation in polynomial time on a turing machine but it is possible to compute it by polynomially many arithmetic operations however for the first condition there are algorithms that run in a number of turing machine steps bounded by a polynomial in the length of binary encoded input but do not take a number of arithmetic operations bounded by a polynomial in the number of input numbers the euclidean algorithm for computing the greatest common divisor of two integers is one example given two integers a displaystyle a and b displaystyle b the algorithm performs o log x2061 a log x2061 b displaystyle o log a log b arithmetic operations on numbers with at most o log x2061 a log x2061 b displaystyle o log a log b bits at the same time the number of arithmetic operations cannot be bounded by the number of integers in the input which is constant in this case there are always only two integers in the input due to the latter observation the algorithm does not run in strongly polynomial time its real running time depends logarithmically on the magnitudes of a displaystyle a and b displaystyle b that is on their length in bits and not only on the number of integers in the input an algorithm that runs in polynomial time but that is not strongly polynomial is said to run in weakly polynomial time 91 14 93 a well known example of a problem for which a weakly polynomial time algorithm is known but is not known to admit a strongly polynomial time algorithm is linear programming weakly polynomial time should not be confused with pseudo polynomial time which depends linearly on the magnitude of values in the problem and is not truly polynomial time complexity classes edit the concept of polynomial time leads to several complexity classes in computational complexity theory some important classes defined using polynomial time are the following p the complexity class of decision problems that can be solved on a deterministic turing machine in polynomial time np the complexity class of decision problems that can be solved on a non deterministic turing machine in polynomial time zpp the complexity class of decision problems that can be solved with zero error on a probabilistic turing machine in polynomial time rp the complexity class of decision problems that can be solved with 1 sided error on a probabilistic turing machine in polynomial time bpp the complexity class of decision problems that can be solved with 2 sided error on a probabilistic turing machine in polynomial time bqp the complexity class of decision problems that can be solved with 2 sided error on a quantum turing machine in polynomial time p is the smallest time complexity class on a deterministic machine which is robust in terms of machine model changes for example a change from a single tape turing machine to a multi tape machine can lead to a quadratic speedup but any algorithm that runs in polynomial time under one model also does so on the other any given abstract machine will have a complexity class corresponding to the problems which can be solved in polynomial time on that machine superpolynomial time edit an algorithm is defined to take superpolynomial time if t n is not bounded above by any polynomial using little omega notation it is nc time for all constants c where n is the input parameter typically the number of bits in the input for example an algorithm that runs for 2n steps on an input of size n requires superpolynomial time more specifically exponential time an algorithm that uses exponential resources is clearly superpolynomial but some algorithms are only very weakly superpolynomial for example the adleman pomerance rumely primality test runs for no log log n time on n bit inputs this grows faster than any polynomial for large enough n but the input size must become impractically large before it cannot be dominated by a polynomial with small degree an algorithm that requires superpolynomial time lies outside the complexity class p cobham s thesis posits that these algorithms are impractical and in many cases they are since the p versus np problem is unresolved it is unknown whether np complete problems require superpolynomial time quasi polynomial time edit quasi polynomial time algorithms are algorithms that run longer than polynomial time yet not so long as to be exponential time the worst case running time of a quasi polynomial time algorithm is 2 o log c x2061 n displaystyle 2 o log c n for some fixed c gt 0 displaystyle c gt 0 for c 1 displaystyle c 1 we get a polynomial time algorithm for c lt 1 displaystyle c lt 1 we get a sub linear time algorithm quasi polynomial time algorithms typically arise in reductions from an np hard problem to another problem for example one can take an instance of an np hard problem say 3sat and convert it to an instance of another problem b but the size of the instance becomes 2 o log c x2061 n displaystyle 2 o log c n in that case this reduction does not prove that problem b is np hard this reduction only shows that there is no polynomial time algorithm for b unless there is a quasi polynomial time algorithm for 3sat and thus all of np similarly there are some problems for which we know quasi polynomial time algorithms but no polynomial time algorithm is known such problems arise in approximation algorithms a famous example is the directed steiner tree problem for which there is a quasi polynomial time approximation algorithm achieving an approximation factor of o log 3 x2061 n displaystyle o log 3 n n being the number of vertices but showing the existence of such a polynomial time algorithm is an open problem other computational problems with quasi polynomial time solutions but no known polynomial time solution include the planted clique problem in which the goal is to find a large clique in the union of a clique and a random graph although quasi polynomially solvable it has been conjectured that the planted clique problem has no polynomial time solution this planted clique conjecture has been used as a computational hardness assumption to prove the difficulty of several other problems in computational game theory property testing and machine learning 91 15 93 the complexity class qp consists of all problems that have quasi polynomial time algorithms it can be defined in terms of dtime as follows 91 16 93 qp x22c3 c x2208 n dtime 2 log c x2061 n displaystyle mbox qp bigcup c in mathbb n mbox dtime left 2 log c n right relation to np complete problems edit in complexity theory the unsolved p versus np problem asks if all problems in np have polynomial time algorithms all the best known algorithms for np complete problems like 3sat etc take exponential time indeed it is conjectured for many natural np complete problems that they do not have sub exponential time algorithms here sub exponential time is taken to mean the second definition presented below on the other hand many graph problems represented in the natural way by adjacency matrices are solvable in subexponential time simply because the size of the input is the square of the number of vertices this conjecture for the k sat problem is known as the exponential time hypothesis 91 17 93 since it is conjectured that np complete problems do not have quasi polynomial time algorithms some inapproximability results in the field of approximation algorithms make the assumption that np complete problems do not have quasi polynomial time algorithms for example see the known inapproximability results for the set cover problem sub exponential time edit the term sub exponential time is used to express that the running time of some algorithm may grow faster than any polynomial but is still significantly smaller than an exponential in this sense problems that have sub exponential time algorithms are somewhat more tractable than those that only have exponential algorithms the precise definition of sub exponential is not generally agreed upon 91 18 93 and we list the two most widely used ones below first definition edit a problem is said to be sub exponential time solvable if it can be solved in running times whose logarithms grow smaller than any given polynomial more precisely a problem is in sub exponential time if for every gt 0 there exists an algorithm which solves the problem in time o 2n the set of all such problems is the complexity class subexp which can be defined in terms of dtime as follows 91 5 93 91 19 93 91 20 93 91 21 93 subexp x22c2 x03b5 gt 0 dtime 2 n x03b5 displaystyle text subexp bigcap varepsilon gt 0 text dtime left 2 n varepsilon right this notion of sub exponential is non uniform in terms of in the sense that is not part of the input and each may have its own algorithm for the problem second definition edit some authors define sub exponential time as running times in 2 o n displaystyle 2 o n 91 17 93 91 22 93 91 23 93 this definition allows larger running times than the first definition of sub exponential time an example of such a sub exponential time algorithm is the best known classical algorithm for integer factorization the general number field sieve which runs in time about 2 o x007e n 1 3 displaystyle 2 tilde o n 1 3 where the length of the input is n another example was the graph isomorphism problem which the best known algorithm from 1982 to 2016 solved in 2 o n log x2061 n displaystyle 2 o left sqrt n log n right however at stoc 2016 a quasi polynomial time algorithm was presented 91 24 93 it makes a difference whether the algorithm is allowed to be sub exponential in the size of the instance the number of vertices or the number of edges in parameterized complexity this difference is made explicit by considering pairs l k displaystyle l k of decision problems and parameters k subept is the class of all parameterized problems that run in time sub exponential in k and polynomial in the input size n 91 25 93 subept dtime 2 o k x22c5 poly n displaystyle text subept text dtime left 2 o k cdot text poly n right more precisely subept is the class of all parameterized problems l k displaystyle l k for which there is a computable function f n x2192 n displaystyle f mathbb n to mathbb n with f x2208 o k displaystyle f in o k and an algorithm that decides l in time 2 f k x22c5 poly n displaystyle 2 f k cdot text poly n exponential time hypothesis edit main article exponential time hypothesis the exponential time hypothesis eth is that 3sat the satisfiability problem of boolean formulas in conjunctive normal form with at most three literals per clause and with n variables cannot be solved in time 2o n more precisely the hypothesis is that there is some absolute constant c gt 0 such that 3sat cannot be decided in time 2cn by any deterministic turing machine with m denoting the number of clauses eth is equivalent to the hypothesis that ksat cannot be solved in time 2o m for any integer k 3 91 26 93 the exponential time hypothesis implies p np exponential time edit an algorithm is said to be exponential time if t n is upper bounded by 2poly n where poly n is some polynomial in n more formally an algorithm is exponential time if t n is bounded by o 2nk for some constant k problems which admit exponential time algorithms on a deterministic turing machine form the complexity class known as exp exp x22c3 c x2208 n dtime 2 n c displaystyle text exp bigcup c in mathbb n text dtime left 2 n c right sometimes exponential time is used to refer to algorithms that have t n 2o n where the exponent is at most a linear function of n this gives rise to the complexity class e e x22c3 c x2208 n dtime 2 c n displaystyle text e bigcup c in mathbb n text dtime left 2 cn right factorial time edit an algorithm is said to be factorial time if t n is upper bounded by the factorial function n factorial time is a subset of exponential time exp because n o 2 n 1 x03f5 displaystyle n o left 2 n 1 epsilon right for all x03f5 gt 0 displaystyle epsilon gt 0 however it is not a subset of e an example of an algorithm that runs in factorial time is bogosort a notoriously inefficient sorting algorithm based on trial and error bogosort sorts a list of n items by repeatedly shuffling the list until it is found to be sorted in the average case each pass through the bogosort algorithm will examine one of the n orderings of the n items if the items are distinct only one such ordering is sorted bogosort shares patrimony with the infinite monkey theorem double exponential time edit an algorithm is said to be double exponential time if t n is upper bounded by 22poly n where poly n is some polynomial in n such algorithms belong to the complexity class 2 exptime 2 exptime x22c3 c x2208 n dtime 2 2 n c displaystyle mbox 2 exptime bigcup c in mathbb n mbox dtime left 2 2 n c right well known double exponential time algorithms include decision procedures for presburger arithmetic computing a gr bner basis in the worst case 91 27 93 quantifier elimination on real closed fields takes at least double exponential time 91 28 93 and can be done in this time 91 29 93 see also edit l notation space complexity references edit a b sipser michael 2006 introduction to the theory of computation course technology inc isbn 160 0 619 21764 2 mehlhorn kurt naher stefan 1990 bounded ordered dictionaries in o log log n time and o n space information processing letters 35 4 183 189 doi 10 1016 0020 0190 90 90022 p tao terence 2010 1 11 the aks primality test an epsilon of room ii pages from year three of a mathematical blog graduate studies in mathematics vol 160 117 providence ri american mathematical society pp 160 82 86 doi 10 1090 gsm 117 isbn 160 978 0 8218 5280 4 mr 160 2780010 lenstra h w jr pomerance carl 2019 primality testing with gaussian periods pdf journal of the european mathematical society 21 4 1229 1269 doi 10 4171 jems 861 mr 160 3941463 s2cid 160 127807021 a b babai l szl fortnow lance nisan n wigderson avi 1993 bpp has subexponential time simulations unless exptime has publishable proofs computational complexity berlin new york springer verlag 3 4 307 318 doi 10 1007 bf01275486 s2cid 160 14802332 bradford phillip g rawlins gregory j e shannon gregory e 1998 efficient matrix chain ordering in polylog time siam journal on computing 27 2 466 490 doi 10 1137 s0097539794270698 mr 160 1616556 holm jacob rotenberg eva 2020 fully dynamic planarity testing in polylogarithmic time in makarychev konstantin makarychev yury tulsiani madhur kamath gautam chuzhoy julia eds proceedings of the 52nd annual acm sigact symposium on theory of computing stoc 2020 chicago il usa june 22 26 2020 association for computing machinery pp 160 167 180 arxiv 1911 03449 doi 10 1145 3357713 3384249 kumar ravi rubinfeld ronitt 2003 sublinear time algorithms pdf sigact news 34 4 57 67 doi 10 1145 954092 954103 s2cid 160 65359 naik ashish v regan kenneth w sivakumar d 1995 on quasilinear time complexity theory pdf theoretical computer science 148 2 325 349 doi 10 1016 0304 3975 95 00031 q mr 160 1355592 sedgewick robert wayne kevin 2011 algorithms 4th 160 ed pearson education p 160 186 papadimitriou christos h 1994 computational complexity reading mass addison wesley isbn 160 0 201 53082 1 cobham alan 1965 the intrinsic computational difficulty of functions proc logic methodology and philosophy of science ii north holland gr tschel martin l szl lov sz alexander schrijver 1988 complexity oracles and numerical computation geometric algorithms and combinatorial optimization springer isbn 160 0 387 13624 x schrijver alexander 2003 preliminaries on algorithms and complexity combinatorial optimization polyhedra and efficiency vol 160 1 springer isbn 160 3 540 44389 4 braverman mark kun ko young rubinstein aviad weinstein omri 2017 eth hardness for densest k subgraph with perfect completeness in klein philip n ed proceedings of the twenty eighth annual acm siam symposium on discrete algorithms soda 2017 barcelona spain hotel porta fira january 16 19 society for industrial and applied mathematics pp 160 1326 1341 arxiv 1504 08352 doi 10 1137 1 9781611974782 86 mr 160 3627815 complexity zoo class qp quasipolynomial time a b impagliazzo russell paturi ramamohan 2001 on the complexity of k sat pdf journal of computer and system sciences 62 2 367 375 doi 10 1006 jcss 2000 1727 mr 160 1820597 aaronson scott 5 april 2009 a not quite exponential dilemma shtetl optimized retrieved 2 december 2009 complexity zoo class subexp deterministic subexponential time moser p 2003 baire s categories on small complexity classes in andrzej lingas bengt j nilsson eds fundamentals of computation theory 14th international symposium fct 2003 malm sweden august 12 15 2003 proceedings lecture notes in computer science vol 160 2751 berlin new york springer verlag pp 160 333 342 doi 10 1007 978 3 540 45077 1 31 isbn 160 978 3 540 40543 6 issn 160 0302 9743 miltersen p b 2001 derandomizing complexity classes handbook of randomized computing combinatorial optimization kluwer academic pub 9 843 doi 10 1007 978 1 4615 0013 1 19 isbn 160 978 1 4613 4886 3 kuperberg greg 2005 a subexponential time quantum algorithm for the dihedral hidden subgroup problem siam journal on computing philadelphia 35 1 188 arxiv quant ph 0302112 doi 10 1137 s0097539703436345 issn 160 1095 7111 s2cid 160 15965140 oded regev 2004 a subexponential time algorithm for the dihedral hidden subgroup problem with polynomial space arxiv quant ph 0406151v1 grohe martin neuen daniel 2021 recent advances on the graph isomorphism problem arxiv 2011 01366 cite journal cite journal requires 124 journal help flum j rg grohe martin 2006 parameterized complexity theory springer p 160 417 isbn 160 978 3 540 29952 3 impagliazzo r paturi r zane f 2001 which problems have strongly exponential complexity journal of computer and system sciences 63 4 512 530 doi 10 1006 jcss 2001 1774 mayr ernst w meyer albert r 1982 the complexity of the word problems for commutative semigroups and polynomial ideals advances in mathematics 46 3 305 329 doi 10 1016 0001 8708 82 90048 2 mr 160 0683204 davenport james h heintz joos 1988 real quantifier elimination is doubly exponential journal of symbolic computation 5 1 2 29 35 doi 10 1016 s0747 7171 88 80004 x mr 160 0949111 collins george e 1975 quantifier elimination for real closed fields by cylindrical algebraic decomposition in brakhage h ed automata theory and formal languages 2nd gi conference kaiserslautern may 20 23 1975 lecture notes in computer science vol 160 33 springer pp 160 134 183 doi 10 1007 3 540 07407 4 17 mr 160 0403962 retrieved from https en wikipedia org w index php title time complexity amp oldid 1131994262 categories analysis of algorithmscomputational complexity theorycomputational resourcestimehidden categories cs1 errors missing periodicalarticles with short descriptionshort description matches wikidatause dmy dates from september 2019 